// https://docs.microsoft.com/en-us/windows/win32/direct3d11/direct3d-11-advanced-stages-compute-create

// HLSL operations : https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-per-component-math

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// User defined types



// https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-struct
struct _BrushStroke { in pixels
	float2 position; // 
    float width; 
	// 
};

//RWStructuredBuffer<_Pixel>  _ActiveLayerBuffer;
// .IncrementCounter : Increments the object's hidden counter.
// # of struct elements and elements size in bytes
// void GetDimensions(
//  out uint numStructs,
//  out uint stride
// );
RWStructuredBuffer<float4> _ActiveLayerBuffer; // 1D of active layer
StructuredBuffer<float2> _BrushStrokePositions; // array of 2D vectors, positions in pixels
// https://docs.microsoft.com/en-us/windows/win32/direct3d11/direct3d-11-advanced-stages-cs-resources
//https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/sm5-object-structuredbuffer
StructuredBuffer<float> _BrushStrokes; // Width

float _BrushStrokeWidth; // in pixels


// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
// https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/sm5-object-rwtexture2d
RWTexture2D<float4> Result; // The Output render texture
// An array of 2D coordinates for brushStroke positions (stored as 1D pixel dimensions)

// A brush stroke x length (2D width)

// A brush stroke color array 

// Layer arrays caching

// Graphics.CopyTexture(). This lets you copy data from any kind of texture to another* (depending the platform). If you copy the contents of a RenderTexture into a Texture2D using CopyTexture() it'll show up changed on the GPU, 


[numthreads(1,1,1)] // if increasing this reduce workload in .Dispatch()
void CSMain (uint3 id : SV_DispatchThreadID)
{

    // check out of bounds for pixels

    // lookup pos of center of brushStroke

    // Blend pixel color if already color

    //Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}
