// https://docs.microsoft.com/en-us/windows/win32/direct3d11/direct3d-11-advanced-stages-compute-create

// HLSL operations : https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-per-component-math

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// User defined types

// https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-struct
struct _Pixel {
    uint position_x;
    uint position_y;
    float4 color;
};

float _TextureWidth;
float _TextureHeight;
float _BrushSizeStart;
float _BrushSizeEnd; // TODO: implement variating brush sizes


RWStructuredBuffer<float4> _ActiveLayerBuffer; // 1D of active layer
StructuredBuffer<_Pixel> _BrushStrokePositionsBuffer; // array of 2D vectors, positions in pixels
StructuredBuffer<_Pixel> _BrushStrokeShapeBuffer; // 1D array of pixels - 1size stroke
RWTexture2D<float4> Result; // The Output render texture
// 
// https://docs.microsoft.com/en-us/windows/win32/direct3d11/direct3d-11-advanced-stages-cs-resources
//https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/sm5-object-structuredbuffer
// https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/sm5-object-rwtexture2d

// Graphics.CopyTexture(). This lets you copy data from any kind of texture to another* (depending the platform). If you copy the contents of a RenderTexture into a Texture2D using CopyTexture() it'll show up changed on the GPU, 


[numthreads(1,1,1)] // if increasing this reduce workload in .Dispatch()
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // id.x : number of brush strokes * size of a brush stroke
    // 

    // position in 1D array (render texture and activeLayer) = # brushStroke * position in brushStroke from center
    // check out of bounds for pixels 
    
    // Determine what brushStroke index is active
    // Max x is all brushStrokes combined
    // Divide x by brushStrokeShapeArray size (brushStroke width * height)  = brushStroke index in positionsBuffer
    uint brushShapeArrayLength = _BrushSizeStart * _BrushSizeStart;
    uint brushStrokeIndexInBrushStrokesPositionsArray = id.x/(brushShapeArrayLength); // from positions array we can get center of brushStroke in 2D pixel coordinates
    uint indexInBrushStrokeShape = id.x - (brushStrokeIndexInBrushStrokesPositionsArray * brushShapeArrayLength);

    //uint positionIn1DArray = 
    // Calculate x and y coordinates in 1D dimension
    // BrushStrokePosition offset by brushStroke Dimensions







    // TODO: Blend pixel color if already color

    // eg. Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}

// helper functions

uint TransferXYtoN(int x, int y){
    int n = x + (_TextureWidth * y);
    if(n >= _TextureWidth * _TextureHeight) return -1; 
    return n;
}

uint2 MidBrushStroke_PixelCoordinate(uint brushSize){
    uint2 midPoint;
    float halfPoint = brushSize/2.0f;
    midPoint.x = (uint)ceil(halfPoint);
    midPoint.y = (uint)ceil(halfPoint);
    return midPoint;
}

