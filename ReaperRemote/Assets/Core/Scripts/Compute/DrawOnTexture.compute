// https://docs.microsoft.com/en-us/windows/win32/direct3d11/direct3d-11-advanced-stages-compute-create

// HLSL operations : https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-per-component-math

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// User defined types

// https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-struct
struct _Pixel {
    uint position_x;
    uint position_y;
    float4 color;
};

uint _TextureWidth;
uint _TextureHeight;
uint _ImageWidth;
uint _ImageHeight;
uint _BrushSizeStart;
uint _BrushSizeEnd; // TODO: implement variating brush sizes
uint _BrushStrokeArrayLength;

RWStructuredBuffer<uint> _JobDoneBuffer; // dummy data to check Kernel job done - full when all id.x are called!
//RWStructuredBuffer<float4> _ActiveLayerBuffer; // 1D of active layer
StructuredBuffer<_Pixel> _BrushStrokePositionsBuffer; // array of 2D vectors, positions in pixels
StructuredBuffer<_Pixel> _BrushStrokeShapeBuffer; // 1D array of pixels - 1size stroke


// https://logins.github.io/graphics/2020/10/31/D3D12ComputeShaders.html
// Quest 2 build works fine - Editor does not!
RWTexture2D<float4> _RenderTexture00; // The Output render texture
RWTexture2D<float4> _RenderTexture01; // The Output render texture
RWTexture2D<float4> _RenderTexture02; // The Output render texture
RWTexture2D<float4> _RenderTexture03; // The Output render texture
RWTexture2D<float4> _RenderTexture04; // The Output render texture
RWTexture2D<float4> _RenderTexture05; // The Output render texture
RWTexture2D<float4> _RenderTexture06; // The Output render texture
RWTexture2D<float4> _RenderTexture07; // The Output render texture
RWTexture2D<float4> _RenderTexture08; // The Output render texture
RWTexture2D<float4> _RenderTexture09; // The Output render texture
RWTexture2D<float4> _RenderTexture10; // The Output render texture
RWTexture2D<float4> _RenderTexture11; // The Output render texture
RWTexture2D<float4> _RenderTexture12; // The Output render texture
RWTexture2D<float4> _RenderTexture13; // The Output render texture
RWTexture2D<float4> _RenderTexture14; // The Output render texture
RWTexture2D<float4> _RenderTexture15; // The Output render texture


// 
// https://docs.microsoft.com/en-us/windows/win32/direct3d11/direct3d-11-advanced-stages-cs-resources
//https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/sm5-object-structuredbuffer
// https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/sm5-object-rwtexture2d

// Graphics.CopyTexture(). This lets you copy data from any kind of texture to another* (depending the platform). If you copy the contents of a RenderTexture into a Texture2D using CopyTexture() it'll show up changed on the GPU, 

uint TransferXYtoN(uint x, uint y){
    uint n = x + (_TextureWidth * y);
    if(n >= _TextureWidth * _TextureHeight) return -1; 
    return n;
}


[numthreads(1,1,1)] // if increasing this reduce workload in .Dispatch()
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // id.x : number of brush strokes * size of a brush stroke
    // 

    // position in 1D array (render texture and activeLayer) = # brushStroke * position in brushStroke from center
    // check out of bounds for pixels 
    
    // Determine what brushStroke index is active
    // Max x is all brushStrokes combined
    // Divide x by brushStrokeShapeArray size (brushStroke width * height)  = brushStroke index in positionsBuffer
    uint indexInBrushStrokesPositionsArray = id.x/(_BrushStrokeArrayLength); 
    uint indexInBrushStrokeShape = id.x - (indexInBrushStrokesPositionsArray * _BrushStrokeArrayLength);

    _Pixel pixelInBrushShape = _BrushStrokeShapeBuffer[indexInBrushStrokeShape];
    _Pixel brushCenterPosition = _BrushStrokePositionsBuffer[indexInBrushStrokesPositionsArray];

    uint posX = brushCenterPosition.position_x + pixelInBrushShape.position_x;
    uint posY = brushCenterPosition.position_y + pixelInBrushShape.position_y;
    
    uint n;

    if( posX < 0 || posX >= _ImageWidth || posY < 0 || posY >= _ImageHeight )
    {
        // do nothing, pixel out of bounds
    }else {
        // draw pixel in maps
        n = TransferXYtoN(posX, posY);  
        //_ActiveLayerBuffer[n] = pixelInBrushShape.color;
        if(posX < _TextureWidth && posY < _TextureHeight ){ // 00
            float2 pixelPosition = float2(posX, posY);
            _RenderTexture00[pixelPosition] = brushCenterPosition.color;
        }
        else if(posX < _TextureWidth * 2 && posY < _TextureHeight){ // 01
            float2 pixelPosition = float2(posX - _TextureWidth, posY);
            _RenderTexture01[pixelPosition] = brushCenterPosition.color;
        }
        else if( posX < _TextureWidth * 3 && posY < _TextureHeight){ //02
            float2 pixelPosition = float2(posX - _TextureWidth * 2, posY);
            _RenderTexture02[pixelPosition] = brushCenterPosition.color;
        }
        else if( posX < _TextureWidth * 4 && posY < _TextureHeight){ //03
            float2 pixelPosition = float2(posX - _TextureWidth * 3, posY);
            _RenderTexture03[pixelPosition] = brushCenterPosition.color;
        }
        else if( posX < _TextureWidth && posY < _TextureHeight * 2){ //04
            float2 pixelPosition = float2(posX, posY - _TextureHeight);
            _RenderTexture04[pixelPosition] = brushCenterPosition.color;
        }
        else if( posX < _TextureWidth * 2 && posY < _TextureHeight * 2){ //05
            float2 pixelPosition = float2(posX - _TextureWidth, posY - _TextureHeight);
            _RenderTexture05[pixelPosition] = brushCenterPosition.color;
        }
        else if( posX < _TextureWidth * 3 && posY < _TextureHeight * 2){ //06
            float2 pixelPosition = float2(posX - _TextureWidth * 2, posY - _TextureHeight);
            _RenderTexture06[pixelPosition] = brushCenterPosition.color;
        }
        else if( posX < _TextureWidth * 4 && posY < _TextureHeight * 2){ //07
            float2 pixelPosition = float2(posX - _TextureWidth * 3, posY - _TextureHeight);
            _RenderTexture07[pixelPosition] = brushCenterPosition.color;
        }
        else if( posX < _TextureWidth && posY < _TextureHeight * 3){ //08
            float2 pixelPosition = float2(posX, posY - _TextureHeight * 2);
            _RenderTexture08[pixelPosition] = brushCenterPosition.color;
        }
        else if( posX < _TextureWidth * 2 && posY < _TextureHeight * 3){ //09
            float2 pixelPosition = float2(posX - _TextureWidth, posY - _TextureHeight * 2);
            _RenderTexture09[pixelPosition] = brushCenterPosition.color;
        }
        else if( posX < _TextureWidth * 3 && posY < _TextureHeight * 3){ //10
            float2 pixelPosition = float2(posX - _TextureWidth * 2, posY - _TextureHeight * 2);
            _RenderTexture10[pixelPosition] = brushCenterPosition.color;
        }
        else if( posX < _TextureWidth * 4 && posY < _TextureHeight * 3){ //11
            float2 pixelPosition = float2(posX - _TextureWidth * 3, posY - _TextureHeight * 2);
            _RenderTexture11[pixelPosition] = brushCenterPosition.color;
        }
        else if( posX < _TextureWidth && posY < _TextureHeight * 4){ //12
            float2 pixelPosition = float2(posX, posY - _TextureHeight * 3);
            _RenderTexture12[pixelPosition] = brushCenterPosition.color;
        }
        else if( posX < _TextureWidth * 2 && posY < _TextureHeight * 4){ //13
            float2 pixelPosition = float2(posX - _TextureWidth, posY - _TextureHeight * 3);
            _RenderTexture13[pixelPosition] = brushCenterPosition.color;
        }
        else if( posX < _TextureWidth * 3 && posY < _TextureHeight * 4){ //14
            float2 pixelPosition = float2(posX - _TextureWidth * 2, posY - _TextureHeight * 3);
            _RenderTexture14[pixelPosition] = brushCenterPosition.color;
        }
        else if( posX < _TextureWidth * 4 && posY < _TextureHeight * 4){ //15
            float2 pixelPosition = float2(posX - _TextureWidth * 3, posY - _TextureHeight * 3);
            _RenderTexture15[pixelPosition] = brushCenterPosition.color;
        }
    }

    _JobDoneBuffer[id.x] = 1;

    // TODO: Blend pixel color if already color

    // eg. Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}

// helper functions



// uint2 MidBrushStroke_PixelCoordinate(uint brushSize){
//     uint2 midPoint;
//     float halfPoint = brushSize/2.0f;
//     midPoint.x = (uint)ceil(halfPoint);
//     midPoint.y = (uint)ceil(halfPoint);
//     return midPoint;
// }

